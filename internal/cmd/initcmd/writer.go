package initcmd

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/certwatch-app/cw-agent/internal/config"
)

// FileExists checks if a file exists.
func FileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// WriteConfig writes the configuration to a YAML file with helpful comments.
func WriteConfig(cfg *config.Config, path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("cannot create directory '%s': %w", dir, err)
		}
	}

	// Generate YAML with comments
	content := generateYAML(cfg)

	// Write file with secure permissions (0600 because it contains API key)
	if err := os.WriteFile(path, []byte(content), 0o600); err != nil {
		if os.IsPermission(err) {
			return fmt.Errorf("permission denied: cannot write to '%s'", path)
		}
		return fmt.Errorf("cannot write file '%s': %w", path, err)
	}

	return nil
}

// generateYAML creates a YAML string with helpful comments.
func generateYAML(cfg *config.Config) string {
	var buf bytes.Buffer

	// Header
	buf.WriteString("# CertWatch Agent Configuration\n")
	buf.WriteString("# Generated by cw-agent init\n")
	buf.WriteString("# Documentation: https://certwatch.app/docs/agent\n")
	buf.WriteString("\n")

	// API section
	buf.WriteString("# API connection settings\n")
	buf.WriteString("api:\n")
	buf.WriteString(fmt.Sprintf("  endpoint: %q\n", cfg.API.Endpoint))
	buf.WriteString("  # Your API key (keep this secret!)\n")
	buf.WriteString(fmt.Sprintf("  key: %q\n", cfg.API.Key))
	buf.WriteString(fmt.Sprintf("  timeout: %s\n", cfg.API.Timeout.String()))
	buf.WriteString("\n")

	// Agent section
	buf.WriteString("# Agent behavior settings\n")
	buf.WriteString("agent:\n")
	buf.WriteString("  # Unique name for this agent (appears in dashboard)\n")
	buf.WriteString(fmt.Sprintf("  name: %q\n", cfg.Agent.Name))
	buf.WriteString("  # How often to sync with CertWatch cloud\n")
	buf.WriteString(fmt.Sprintf("  sync_interval: %s\n", cfg.Agent.SyncInterval.String()))
	buf.WriteString("  # How often to scan certificates locally\n")
	buf.WriteString(fmt.Sprintf("  scan_interval: %s\n", cfg.Agent.ScanInterval.String()))
	buf.WriteString("  # Number of concurrent certificate scans\n")
	buf.WriteString(fmt.Sprintf("  concurrency: %d\n", cfg.Agent.Concurrency))
	buf.WriteString("  # Logging level: debug, info, warn, error\n")
	buf.WriteString(fmt.Sprintf("  log_level: %s\n", cfg.Agent.LogLevel))
	buf.WriteString("\n")

	// Certificates section
	buf.WriteString("# Certificates to monitor\n")
	buf.WriteString("certificates:\n")

	for _, cert := range cfg.Certificates {
		buf.WriteString(fmt.Sprintf("  - hostname: %q\n", cert.Hostname))
		buf.WriteString(fmt.Sprintf("    port: %d\n", cert.Port))

		if len(cert.Tags) > 0 {
			buf.WriteString("    tags:\n")
			for _, tag := range cert.Tags {
				buf.WriteString(fmt.Sprintf("      - %q\n", tag))
			}
		}

		if cert.Notes != "" {
			// Handle multi-line notes
			if strings.Contains(cert.Notes, "\n") {
				buf.WriteString("    notes: |\n")
				for _, line := range strings.Split(cert.Notes, "\n") {
					buf.WriteString(fmt.Sprintf("      %s\n", line))
				}
			} else {
				buf.WriteString(fmt.Sprintf("    notes: %q\n", cert.Notes))
			}
		}

		buf.WriteString("\n")
	}

	return buf.String()
}
